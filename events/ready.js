const { Events } = require('discord.js');

module.exports = {
	name: Events.ClientReady,
	once: true,
	async execute(client) {

		// On envoi un messagePlanif dans la console pour indiquer que le bot est en pr√©paration
		console.log('Pr√©paration du bot...\n');

		// On r√©cup√®re le salon "planifs-wipes" et on cherche si des messages de planifs ont d√©j√† √©t√© envoy√©s dans le salon
		let channelPlanifWipesName = 'üìçplanifs-wipes';
		const channelPlanifWipes = client.channels.cache.find(channelPlanifWipes => channelPlanifWipes.name === channelPlanifWipesName);
		const messagesPlanifWipes = await channelPlanifWipes.messages.fetch();

		// Si des messages de planifs ont d√©j√† √©t√© envoy√©s, on cr√©√© un collecteur pour chaque message pour r√©cup√©rer les r√©actions des utilisateurs
		if (messagesPlanifWipes.size > 0) {
			console.log('Des messages de planifs de wipes ont d√©j√† √©t√© envoy√©s dans le salon "planifs-wipes", r√©cup√©ration des messages...');
			for(const messagePlanif of messagesPlanifWipes.values()) {
				// Si le message est vide, on passe au message suivant
				if(messagePlanif.content === undefined) continue;
				
				// Si la premi√®re ligne du message est "__**Prochains wipes**__", on passe au message suivant
				if (messagePlanif.content.startsWith('__**Prochains wipes**__')) continue;

				// Liste des utilisateurs qui sont en train de r√©pondre √† l'heure de d√©but de jeu
				let usersProcessingYes = [];

				// Listes des utilisateurs qui ont r√©agi avec les emojis
				let usersYes = [];
				let usersNotSure = [];
				let usersNo = [];

				// Map des utilisateurs pr√©sents dans la liste 'usersYes' avec l'heure de d√©but de jeu
				const usersResponse = new Map();

				// On lit le messagePlanif pour r√©cup√©rer la date de wipe et on supprime les '**'
				const messageContent = messagePlanif.content;
				const messageContentSplit = messageContent.split('\n');
				const wipeDate = messageContentSplit[1].slice(2, messageContentSplit[1].length - 2);
				console.log('\n‚òÖ Date de wipe : ' + wipeDate);

				// On r√©cup√®re les utilisateurs qui ont r√©agi avec les emojis et on les ajoute dans les listes correspondantes
				for(const reaction of messagePlanif.reactions.cache.values()) {
					const users = await reaction.users.fetch();
					for(const user of users.values()) {
						if (!user.bot) {
							if (reaction.emoji.name === '‚úÖ') {
								console.log(user.username + ' a r√©agi avec l\'emoji ‚úÖ');
								usersYes.push(user.username);
							}
							else if (reaction.emoji.name === '‚ùì') {
								console.log(user.username + ' a r√©agi avec l\'emoji ‚ùì');
								usersNotSure.push(user.username);
							}
							else if (reaction.emoji.name === '‚ùå') {
								console.log(user.username + ' a r√©agi avec l\'emoji ‚ùå');
								usersNo.push(user.username);
							}
						}
					};
				};

				// On cherche les lignes qui contiennent les noms des utilisateurs qui ont r√©agi avec l'emoji '‚úÖ' et on r√©cup√®re l'heure de d√©but de jeu
				const messageUsersHoursSplit = messagePlanif.content.split('\n');
				for(const line of messageUsersHoursSplit.values()) {
					if (line.includes(' - ')) {
						const user = line.split(' - ')[0].slice(2);
						if(usersYes.includes(user))
						{
							const userResponse = line.split(' - ')[1];
							console.log(user + ' a indiqu√© comme heure de d√©but de jeu ' + userResponse);
							usersResponse.set(user, userResponse);
						}
					}
				};

				updateMess();

				const filter = (reaction, user) => {
					return ['‚úÖ', '‚ùì', '‚ùå'].includes(reaction.emoji.name) && !user.bot;
				};
		
				const collector = messagePlanif.createReactionCollector(filter);
		
				collector.on('collect', async (reaction, user) => {
					// R√©cup√®re toutes les r√©actions de l'utilisateur
					const userReactions = messagePlanif.reactions.cache.filter(reaction => reaction.users.cache.has(user.id));
		
					// Si l'utilisateur est d√©j√† dans la liste 'usersProcessingYes', on ne tiens pas compte de sa r√©action
					if (usersProcessingYes.includes(user.username))
					{
						for (const react of userReactions.values()) {
							if (reaction.emoji.name === react.emoji.name) {
								await react.users.remove(user.id);
								return;
							}
						}
					}
		
					// Supprime toutes les r√©actions de l'utilisateur sauf celle qu'il vient de faire
					for (const react of userReactions.values()) {
						if (reaction.emoji.name !== react.emoji.name) {
							await react.users.remove(user.id);
						}
					}
		
					// Supprime le nom de l'utilisateur des liste de r√©actions
					if (usersYes.includes(user.username)) usersYes.splice(usersYes.indexOf(user.username), 1);
					if (usersNotSure.includes(user.username)) usersNotSure.splice(usersNotSure.indexOf(user.username), 1);
					if (usersNo.includes(user.username)) usersNo.splice(usersNo.indexOf(user.username), 1);
		
					// Supprime la pr√©c√©dente r√©ponse de l'utilisateur sur l'heure de d√©but de jeu
					if (usersResponse.has(user.username)) usersResponse.delete(user.username);
		
					// Ajoute le nom de l'utilisateur √† la liste de r√©actions '‚úÖ'
					if (reaction.emoji.name === '‚úÖ') {
						console.log(user.username + ' a r√©agi avec l\'emoji ‚úÖ pour le wipe du ' + wipeDate);
						usersProcessingYes.push(user.username);
		
						// Envoie un messagePlanif priv√© √† l'utilisateur pour qu'il puisse indiquer l'heure de d√©but de jeu
						const messagePlanif = await user.send(`√Ä quelle heure tu commenceras √† jouer pour le wipe du ${wipeDate} ? R√©ponds avec l'heure au format \`HH:MM\`, ou avec \`?\` si tu ne sais pas.`);
						const filter = async (response) => {
							let validate = response.author.id === user.id && (/^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/.test(response.content) || response.content === '?');
							if (response.author.id === user.id && !validate) await user.send('La r√©ponse doit √™tre au format `HH:MM`, ou r√©pond avec `?` si tu ne sais pas √† quelle heure tu vas jouer.');
							return validate;
						};
						const collector = messagePlanif.channel.createMessageCollector({ filter, max: 1, time: 60000 });
		
						// Ajoute la r√©ponse de l'utilisateur √† la map 'usersResponse'
						collector.on('collect', response => {
							console.log(user.username + ' a r√©pondu qu\'il commencera √† jouer √† ' + response.content + ' pour le wipe du ' + wipeDate);
							usersResponse.set(user.username, response.content);
							collector.stop();
						});
						
						// Si l'utilisateur n'a pas r√©pondu √† temps, on met '?' comme heure de d√©but de jeu
						collector.on('end', async collected => {
							if (collected.size === 0) {
								console.log(user.username + ' n\'a pas r√©pondu √† temps pour l\'heure de d√©but de jeu pour le wipe du ' + wipeDate)
								await user.send(`Tu n'as pas r√©pondu √† temps, je vais donc mettre \`?\` comme heure de d√©but de jeu. Si tu veux changer ton heure de d√©but de jeu, tu peux r√©agir √† nouveau avec l'emoji ‚úÖ.`);
								usersResponse.set(user.username, '?');
							}
							usersProcessingYes.splice(usersProcessingYes.indexOf(user.username), 1);
							usersYes.push(user.username);
							updateMess();
						});
					} 
					
					// Ajoute le nom de l'utilisateur √† la liste de r√©actions '‚ùì'
					else if (reaction.emoji.name === '‚ùì') {
						console.log(user.username + ' a r√©agi avec l\'emoji ‚ùì pour le wipe du ' + wipeDate)
						usersNotSure.push(user.username);
						updateMess();
					} 
					
					// Ajoute le nom de l'utilisateur √† la liste de r√©actions '‚ùå'
					else if (reaction.emoji.name === '‚ùå') {
						console.log(user.username + ' a r√©agi avec l\'emoji ‚ùå pour le wipe du ' + wipeDate)
						usersNo.push(user.username);
						updateMess();
					}
				});
		
				// Met √† jour le messagePlanif
				function updateMess() {
					let new_content = `**${wipeDate}**`;
		
					if (usersYes.length > 0) {
						usersYes.sort((a, b) => {
							if (usersResponse.get(a) === '?') return 1;
							if (usersResponse.get(b) === '?') return -1;
							return usersResponse.get(a) > usersResponse.get(b) ? 1 : -1;
						});

						new_content += `\n\n‚úÖ ${usersYes.map(user => `${user} - ${usersResponse.get(user) == undefined ? "?" : usersResponse.get(user) }`).join('\n‚úÖ ')}`;
					}
		
					if (usersNotSure.length > 0) {
						new_content += `\n\n‚ùì ${usersNotSure.join('\n‚ùì ')}`;
					}
		
					if (usersNo.length > 0) {
						new_content += `\n\n‚ùå ${usersNo.join('\n‚ùå ')}`;
					}
		
					messagePlanif.edit({ content: new_content });
				}
			};
			console.log('\nFin de la r√©cup√©ration des messages de planifs de wipes !\n');
		}

		// On r√©cup√®re le salon "planifs-tournages" et on cherche si des messages de planifs ont d√©j√† √©t√© envoy√©s dans le salon
		let channelPlanifShootingName = 'üé•planifs-tournages';
		const channelPlanifShooting = client.channels.cache.find(channelPlanifShooting => channelPlanifShooting.name === channelPlanifShootingName);
		const messagesPlanifShooting = await channelPlanifShooting.messages.fetch();

		// Si des messages de planifs ont d√©j√† √©t√© envoy√©s, on cr√©√© un collecteur pour chaque message pour r√©cup√©rer les r√©actions des utilisateurs
		if (messagesPlanifShooting.size > 0) {
			console.log('Des messages de planifs de tournages ont d√©j√† √©t√© envoy√©s dans le salon "planifs-tournages", r√©cup√©ration des messages...');
			for(const messagePlanif of messagesPlanifShooting.values()) {
				// Si le message est vide, on passe au message suivant
				if(messagePlanif.content === undefined) continue;
				
				// Si la premi√®re ligne du message est "__**Prochains tournages**__", on passe au message suivant
				if (messagePlanif.content.startsWith('__**Prochains tournages**__')) continue;

				// Listes des utilisateurs qui ont r√©agi avec les emojis
				let usersYes = [];
				let usersNotSure = [];
				let usersNo = [];

				// On lit le messagePlanif pour r√©cup√©rer la date de tournage et on supprime les '**'
				const messageContent = messagePlanif.content;
				const messageContentSplit = messageContent.split('\n');
				const shootingDate = messageContentSplit[1].slice(2, messageContentSplit[1].length - 2);
				console.log('\n‚òÖ Date de tournage : ' + shootingDate);

				// On r√©cup√®re les utilisateurs qui ont r√©agi avec les emojis et on les ajoute dans les listes correspondantes
				for(const reaction of messagePlanif.reactions.cache.values()) {
					const users = await reaction.users.fetch();
					for(const user of users.values()) {
						if (!user.bot) {
							if (reaction.emoji.name === '‚úÖ') {
								console.log(user.username + ' a r√©agi avec l\'emoji ‚úÖ');
								usersYes.push(user.username);
							}
							else if (reaction.emoji.name === '‚ùì') {
								console.log(user.username + ' a r√©agi avec l\'emoji ‚ùì');
								usersNotSure.push(user.username);
							}
							else if (reaction.emoji.name === '‚ùå') {
								console.log(user.username + ' a r√©agi avec l\'emoji ‚ùå');
								usersNo.push(user.username);
							}
						}
					};
				};

				updateMess();

				const filter = (reaction, user) => {
					return ['‚úÖ', '‚ùì', '‚ùå'].includes(reaction.emoji.name) && !user.bot;
				};
		
				const collector = messagePlanif.createReactionCollector(filter);
		
				collector.on('collect', async (reaction, user) => {
					// R√©cup√®re toutes les r√©actions de l'utilisateur
					const userReactions = messagePlanif.reactions.cache.filter(reaction => reaction.users.cache.has(user.id));
		
					// Supprime toutes les r√©actions de l'utilisateur sauf celle qu'il vient de faire
					for (const react of userReactions.values()) {
						if (reaction.emoji.name !== react.emoji.name) {
							await react.users.remove(user.id);
						}
					}
		
					// Supprime le nom de l'utilisateur des liste de r√©actions
					if (usersYes.includes(user.username)) usersYes.splice(usersYes.indexOf(user.username), 1);
					if (usersNotSure.includes(user.username)) usersNotSure.splice(usersNotSure.indexOf(user.username), 1);
					if (usersNo.includes(user.username)) usersNo.splice(usersNo.indexOf(user.username), 1);
		
					// Ajoute le nom de l'utilisateur √† la liste de r√©actions '‚úÖ'
					if (reaction.emoji.name === '‚úÖ') {
						console.log(user.username + ' a r√©agi avec l\'emoji ‚úÖ pour le tournage du ' + shootingDate);
						usersYes.push(user.username);
						updateMess();
					} 
					
					// Ajoute le nom de l'utilisateur √† la liste de r√©actions '‚ùì'
					else if (reaction.emoji.name === '‚ùì') {
						console.log(user.username + ' a r√©agi avec l\'emoji ‚ùì pour le tournage du ' + shootingDate)
						usersNotSure.push(user.username);
						updateMess();
					} 
					
					// Ajoute le nom de l'utilisateur √† la liste de r√©actions '‚ùå'
					else if (reaction.emoji.name === '‚ùå') {
						console.log(user.username + ' a r√©agi avec l\'emoji ‚ùå pour le tournage du ' + shootingDate)
						usersNo.push(user.username);
						updateMess();
					}
				});
		
				// Met √† jour le messagePlanif
				function updateMess() {
					let new_content = `**${shootingDate}**`;
		
					if (usersYes.length > 0) {
						new_content += `\n\n‚úÖ ${usersYes.join('\n‚úÖ ')}`;
					}
		
					if (usersNotSure.length > 0) {
						new_content += `\n\n‚ùì ${usersNotSure.join('\n‚ùì ')}`;
					}
		
					if (usersNo.length > 0) {
						new_content += `\n\n‚ùå ${usersNo.join('\n‚ùå ')}`;
					}
		
					messagePlanif.edit({ content: new_content });
				}
			};
			console.log('\nFin de la r√©cup√©ration des messages de planifs de tournages !\n');
		}
		console.log('\nLe bot est pr√™t ! Connect√© en tant que ' + client.user.tag + ' !\n');
	},
};